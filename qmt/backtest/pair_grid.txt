#coding:gbk
import pandas as pd
import numpy as np
import talib
import json
import os
from datetime import datetime

STATE_FILE = 'pair_grid_strategy_state.json'

# 全局常量（更新）
THRESHOLD_RATIO = 0.01      # 比值偏离阈值：±15% 触发切换
WINDOW = 20                 # 滚动窗口天数
GRID_MULTIPLIER = 1.0       # 网格放大系数

def init(C):
    C.strategy_name = 'pair_grid'
    C.stock_A = '159518.SZ'  # 华宝油气
    C.stock_B = '513350.SH'  # 标普油气ETF
    C.stocks = [C.stock_A, C.stock_B]
    C.account_id = 'testS'
    C.unit_amount = 30000    # 每次交易金额（元）
    
    # 当前持有标的
    C.current_held = None
    
    # 每个标的独立的网格状态
    C.grid_state = {
        C.stock_A: {'base_price': None, 'logical_holding': 0},
        C.stock_B: {'base_price': None, 'logical_holding': 0}
    }

    # 用于价值锚定的配对均值
    C.last_ratio_mean = None

    # 加载历史状态
    load_all_states(C)

    # 设置标的池
    C.set_universe(C.stocks)

def handlebar(C):
    bar_date = timetag_to_datetime(C.get_bar_timetag(C.barpos - 1), '%Y%m%d%H%M%S')
    print(f"\n=== 回测日期: {bar_date} ===")

    # 获取两只ETF的行情
    prices = C.get_market_data_ex(['high','low','close'], C.stocks, period="1d", count=WINDOW+1, end_time=bar_date)
    
    if len(prices) < 2:
        print("数据不足，跳过")
        return

    price_A = prices[C.stock_A]['close'][-1]
    price_B = prices[C.stock_B]['close'][-1]

    # --- 1. 配对逻辑：直接使用比值偏离 ---
    close_A = np.array(prices[C.stock_A]['close'][-WINDOW:])
    close_B = np.array(prices[C.stock_B]['close'][-WINDOW:])
    ratio_series = close_A / close_B
    mean_ratio = np.mean(ratio_series)
    
    current_ratio = price_A / price_B

    print(f"配对分析: A/B={current_ratio:.4f}, 历史均值={mean_ratio:.4f}, 阈值=[{mean_ratio*(1-THRESHOLD_RATIO):.4f}, {mean_ratio*(1+THRESHOLD_RATIO):.4f}]")

    target_stock = None
    if current_ratio > mean_ratio * (1 + THRESHOLD_RATIO):
        print('switch to A')
        target_stock = C.stock_A  # A相对贵，持有A
    elif current_ratio < mean_ratio * (1 - THRESHOLD_RATIO):
        target_stock = C.stock_B  # B相对贵，持有B
        print('switch to B')
    else:
        target_stock = C.current_held  # 维持现状

    # 默认持有A
    if target_stock is None:
        target_stock = C.stock_A

    # --- 2. 换仓逻辑 + 基准价继承 ---
    if C.current_held and C.current_held != target_stock:
        print(f"切换持仓: {C.current_held} → {target_stock}")
        
        old_stock = C.current_held
        new_stock = target_stock
        old_base = C.grid_state[old_stock]['base_price']
        price_old = prices[old_stock]['close'][-1]
        price_new = prices[new_stock]['close'][-1]

        # 平仓
        _close_position(C, old_stock, bar_date)
        C.current_held = None

        # === 继承新持仓的 base_price（价值等价）===
        if old_base is not None:
            if new_stock == C.stock_A:
                conversion_ratio = mean_ratio  # A/B 均值
            else:
                conversion_ratio = 1.0 / mean_ratio  # B/A

            new_base_price = old_base * conversion_ratio * (price_new / price_old)
            C.grid_state[new_stock]['base_price'] = new_base_price
            print(f"继承基准价: {old_stock}@{old_base:.4f} → {new_stock}@{new_base_price:.4f} "
                  f"(转换比率={conversion_ratio:.4f})")
        else:
            # 初始化新 base_price
            C.grid_state[new_stock]['base_price'] = price_new * 1.05

        C.last_ratio_mean = mean_ratio

    # 设置新持仓
    if C.current_held != target_stock:
        C.current_held = target_stock
        print(f"新持仓目标: {C.current_held}")
        save_strategy_state(C)

    # --- 3. 网格交易 ---
    if C.current_held:
        _run_grid_trading(C, C.current_held, bar_date)

def _run_grid_trading(C, stock, bar_date):
    """对指定股票执行网格交易"""
    prices = C.get_market_data_ex(['high','low','close'], [stock], period="1d", count=30, end_time=bar_date)
    prices = prices[stock]
    current_price = prices['close'][-1]
    high = prices['high'].values
    low = prices['low'].values
    close = prices['close'].values

    rsi = talib.RSI(close, timeperiod=6)[-1]
    atr = talib.ATR(high, low, close, timeperiod=4)[-1]
    grid_unit = get_grid_unit(stock, current_price, atr) * GRID_MULTIPLIER

    base_price = C.grid_state[stock]['base_price']
    logical_holding = C.grid_state[stock]['logical_holding']

    if base_price is None:
        base_price = prices['close'][-10:].max()
        C.grid_state[stock]['base_price'] = base_price
        print(f"首次初始化 base_price = {base_price:.3f}")

    account = get_trade_detail_data(C.account_id, '', 'account')[0]
    available_cash = int(account.m_dAvailable)

    positions = get_trade_detail_data(C.account_id, '', 'position')
    holdings = {p.m_strInstrumentID + '.' + p.m_strExchangeID: p.m_nCanUseVolume for p in positions}
    current_holding = holdings.get(stock, 0)

    executed = False
    print((current_price, base_price, current_price <= base_price - grid_unit))
    # === 卖出逻辑 ===
    if current_price >= base_price + grid_unit:
        print('sell')
        sell_amount = C.unit_amount
        if rsi > 80:
            pass
        else:
            sell_amount *= 0.9  # 九折金额

        unit_to_sell = int(sell_amount / current_price)
        unit_to_sell = (unit_to_sell // 100) * 100
        unit_to_sell = min(unit_to_sell, current_holding)

        if unit_to_sell > 0:
            passorder(24, 1101, C.account_id, stock, 14, -1, unit_to_sell, C.strategy_name, 1, '', C)
            C.grid_state[stock]['logical_holding'] -= unit_to_sell
            print(f"网格卖出 {unit_to_sell} 股 {stock} @ {current_price:.3f}")
            if C.grid_state[stock]['logical_holding'] > 0:
                C.grid_state[stock]['base_price'] = current_price
            else:
                C.grid_state[stock]['base_price'] = None
            executed = True

    # === 买入逻辑 ===
    elif current_price <= base_price - grid_unit:
        print('buy')
        buy_amount = C.unit_amount
        if rsi < 20:
            buy_amount *= 1.1

        unit_to_buy = int(buy_amount / current_price)
        unit_to_buy = (unit_to_buy // 100) * 100

        if available_cash >= current_price * unit_to_buy and unit_to_buy > 0:
            passorder(23, 1101, C.account_id, stock, 14, -1, unit_to_buy, C.strategy_name, 1, '', C)
            C.grid_state[stock]['logical_holding'] += unit_to_buy
            C.grid_state[stock]['base_price'] = current_price
            print(f"网格买入 {unit_to_buy} 股 {stock} @ {current_price:.3f}")
            executed = True
        else:
            print("现金不足或买入量为0")

    # === 动态调整 base_price ===
    if not executed and base_price is not None:
        if abs(base_price / current_price - 1) > 0.06:
            old_base = base_price
            beta = 0.1
            C.grid_state[stock]['base_price'] = base_price + beta * (current_price - base_price)
            print(f"动态调整 base_price: {old_base:.3f} → {C.grid_state[stock]['base_price']:.3f}")

    if executed or (not executed and C.grid_state[stock]['base_price'] != base_price):
        save_strategy_state(C)

def _close_position(C, stock, bar_date):
    """平掉指定股票的持仓"""
    positions = get_trade_detail_data(C.account_id, '', 'position')
    holdings = {p.m_strInstrumentID + '.' + p.m_strExchangeID: p.m_nCanUseVolume for p in positions}
    holding = holdings.get(stock, 0)
    if holding > 0:
        passorder(24, 1101, C.account_id, stock, 14, -1, holding, C.strategy_name, 1, '', C)
        print(f"平仓 {holding} 股 {stock}")
        C.grid_state[stock]['logical_holding'] = 0
        C.grid_state[stock]['base_price'] = None
    else:
        print(f"无持仓可平: {stock}")

def get_grid_unit(stock, current_price, atr):
    """定义不同品种的网格单位"""
    if stock == "159985.SZ":
        return max(atr, current_price * 0.01)
    return atr

def load_all_states(C):
    """加载所有状态"""
    if not os.path.exists(STATE_FILE):
        print("无历史状态文件，使用初始状态")
        return
        
    return

    try:
        with open(STATE_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
            C.current_held = data.get('current_held')
            C.last_ratio_mean = data.get('last_ratio_mean')
            grid_data = data.get('grid_state', {})
            for stock in C.stocks:
                if stock in grid_data:
                    C.grid_state[stock] = grid_data[stock]
            print(f"已加载历史状态: current_held={C.current_held}")
    except Exception as e:
        print(f"加载状态失败: {e}")

def save_strategy_state(C):
    """保存状态"""
    data = {
        'current_held': C.current_held,
        'last_ratio_mean': C.last_ratio_mean,
        'grid_state': C.grid_state
    }
    try:
        with open(STATE_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)
    except Exception as e:
        print(f"保存状态失败: {e}")
