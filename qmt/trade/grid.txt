#encoding:gbk
import datetime
import time
import pandas as pd
import numpy as np
import talib
import json
import os

"""
策略说明：豆粕网格
"""

class a():
    pass

A = a()  # 创建空类实例，用于保存状态

def init(C):
    A.stock = '159985.SZ'
    A.strategy_name = 'grid_' + A.stock.replace(".", "") + '_rviqraznvx'
    A.acct = account
    A.acct_type = accountType
    A.unit_amount = 30000
    A.state_file =  A.strategy_name + '.json'
    A.waiting_list = []  # 未确认的委托，防止重复下单
    A.prices_date = None
    A.base_price = None
    A.logical_holding = 0

    C.set_universe([A.stock])

    A.waiting_list = rebuild_waiting_list_from_open_orders()

    state = load_strategy_state(A.state_file, A.stock)
    if state and state['base_price'] is not None:
        A.base_price = state['base_price']
        A.logical_holding = state['logical_holding']
        print(f"从文件加载状态: base_price={A.base_price}, 持仓={A.logical_holding}")
    else:
        print("未找到历史状态，将使用首次均线初始化 base_price")

    C.run_time("f","60nSecond","2025-1-1 09:31:00")
    C.run_time("g","1nDay","2025-1-1 14:59:30")

def f(C):
    now = datetime.datetime.now()
    now_time = now.strftime('%H%M%S')
    today = now.strftime('%Y%m%d')
    # 跳过非交易时间
    if not ('093000' <= now_time <= '113000' or '130000' <= now_time <= '150000'):
        return

    account = get_trade_detail_data(A.acct, A.acct_type, 'account')
    if len(account) == 0:
        print(f'账号{A.acct} 未登录 请检查')
        return
    account = account[0]
    available_cash = int(account.m_dAvailable)

    if A.waiting_list:
        found_list = []
        orders = get_trade_detail_data(A.acct, A.acct_type, 'order')
        for order in orders:
            if order.m_strRemark in A.waiting_list:
                if order.m_nOrderStatus in {54, 56, 57}:  # 已撤, 已成, 废单
                    found_list.append(order.m_strRemark)
        A.waiting_list = [i for i in A.waiting_list if i not in found_list]
    if A.waiting_list:
        print(f"当前有未查到委托 {A.waiting_list} 暂停后续报单")
        return

    # 获取持仓
    positions = get_trade_detail_data(A.acct, A.acct_type, 'position')
    holdings = {}
    for pos in positions:
        key = pos.m_strInstrumentID + '.' + pos.m_strExchangeID
        holdings[key] = pos.m_nCanUseVolume  # 可卖数量

    current_holding = holdings.get(A.stock, 0)

    # === 核心逻辑 ===
    executed = False

    # 获取当前市价
    stock = A.stock
    data = C.get_full_tick([stock])
    
    if A.stock not in data:
        print(f"无法获取 {stock} 的实时价格")
        return

    current_price = data[stock]['lastPrice']

    atr = 0
    rsi = 50
    grid_unit = 0
    max_price = 0
    yesterday_price = 0
    
    if A.prices_date is None or A.prices_date != today:
        prices = C.get_market_data_ex(['high','low','close'],[stock], period = "1d",count=30,end_time = today)
        A.prices_date = today
        prices = prices[stock]
        yesterday_price = prices[-1]

        avg_price = prices['close'][-10:].mean()
        max_price = prices['close'][-10:].max()
        
        high = prices['high']
        low = prices['low']
        close = prices['close']
        rsi = talib.RSI(close, timeperiod=6)[-1]

        atr = talib.ATR(high.values, low.values, close.values, timeperiod=4)[-1]
        grid_unit = get_grid_unit(stock, yesterday_price, atr)
    
    if grid_unit == 0 or max_price == 0:
        print("grid_unit or max_price is 0")
        return

    base_price = A.base_price  # copy a local base_price

    if base_price is None:
        base_price = max_price

    print({
        'yesterday_price': yesterday_price,
        'current_price': current_price,
        'base_price': base_price,
        'atr': atr,
        'grid_unit': grid_unit})

    if current_price >= base_price + grid_unit:
        sell_amount = A.unit_amount  # 基准卖出金额
        if rsi > 80:
            pass
        else:
            sell_amount *= 0.9  # 九折金额

        # 根据当前价格计算应卖出的股数
        unit_to_sell = int(sell_amount / current_price)
        
        # 调整为100的整数倍
        unit_to_sell = (unit_to_sell // 100) * 100
        
        # 确保卖出数量不超过当前持仓
        unit_to_sell = min(unit_to_sell, current_holding)
        
        
        if unit_to_sell > 0:  # 确保至少卖出100股
            timestamp = int(time.time())
            msg = f"{A.strategy_name}_sell_{unit_to_sell}_{timestamp}"
            passorder(24, 1101, A.acct, stock, 14, -1, unit_to_sell, A.strategy_name, 1, msg, C)
            A.waiting_list.append(msg)
            print("卖出 %d 股，价格: %.3f, 总金额: %.2f" % (unit_to_sell, current_price, unit_to_sell * current_price))
            if A.logical_holding > 0:
                A.base_price = current_price
            else:
                A.base_price = None

            A.logical_holding -= unit_to_sell
            executed = True
            if A.base_price is not None:
                print("更新基准价为: %.3f" % A.base_price)
            else:
                print("更新基准价为: None")
    # 向下突破：买入一个单位 (基于金额)
    else:
        if current_price <= base_price - grid_unit:
            buy_amount = A.unit_amount  # 基准买入金额
            if rsi < 20:
                buy_amount *= 1.1  # 加码10%
                
            # 计算可以买入多少股
            unit_to_buy = int(buy_amount / current_price)
            
            # 调整为100的整数倍
            unit_to_buy = (unit_to_buy // 100) * 100
            
            if available_cash >= current_price * unit_to_buy and unit_to_buy > 0:
                timestamp = int(time.time())
                msg = f"{A.strategy_name}_buy_{unit_to_buy}_{timestamp}"
                passorder(23, 1101, A.acct, stock, 14, -1, unit_to_buy, A.strategy_name, 1, msg, C)
                A.waiting_list.append(msg)
                print("买入 %d 股，价格: %.3f, 总金额: %.2f" % (unit_to_buy, current_price, unit_to_buy * current_price))
                # 更新基准价为当前成交价
                A.base_price = current_price
                A.logical_holding += unit_to_buy
                executed = True
                print("更新基准价为: %.3f" % A.base_price)
            else:
                # A.base_price = current_price      # 如果跌幅较大，可能提高收益
                # executed = True
                print("现金不足或计算股数为0，无法买入")

    if executed:
        save_strategy_state(A.state_file, stock, A.base_price, A.logical_holding)
        if A.base_price is not None:
            print(f"状态已保存: base_price={A.base_price:.3f}, 持仓={A.logical_holding}")
        else:
            print(f"状态已保存: base_price=None, 持仓={A.logical_holding}")

def g(C):
    state = load_strategy_state(A.state_file, A.stock)
    if state and state['base_price'] is not None:
        A.base_price = state['base_price']
        A.logical_holding = state['logical_holding']

        data = C.get_full_tick([A.stock])
        
        if A.stock not in data:
            print(f"无法获取 {A.stock} 的实时价格")
            return

        current_price = data[A.stock]['lastPrice']

        if abs(A.base_price / current_price - 1) > 0.05:
            original_base_price = A.base_price
            beta = 0.1  # 追踪速度：0.1~0.3（越大越快）
            A.base_price = A.base_price + beta * (current_price - A.base_price)
                
            save_strategy_state(A.state_file, A.stock, A.base_price, A.logical_holding)
            print(f"动态调整base_price： 原来base_price={original_base_price:.3f}，现在={A.base_price:.3f},价格={current_price:.3f}")  

def rebuild_waiting_list_from_open_orders():
    orders = get_trade_detail_data(A.acct, A.acct_type, 'order')
    open_orders = []
    for order in orders:
        if order.m_nOrderStatus in [49, 50, 51, 52, 55] and A.strategy_name in order.m_strRemark:  # 待报, 已报, 已报待撤, 部成待撤, 部成
            open_orders.append(order.m_strRemark)

    return open_orders

def load_strategy_state(file, stock):
    """从文件加载策略状态"""
    if not os.path.exists(file):
        return None
    try:
        with open(file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # 检查是否包含当前股票的状态
            if stock in data:
                state = data[stock]
                return {
                    'base_price': state.get('base_price'),
                    'logical_holding': state.get('logical_holding', 0)
                }
    except Exception as e:
        print(f"加载策略状态失败: {e}")
    return None

def save_strategy_state(file, stock, base_price, logical_holding):
    """保存策略状态到文件"""
    data = {}
    if os.path.exists(file):
        try:
            with open(file, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"读取状态文件异常，将新建: {e}")

    # 更新当前股票状态
    data[stock] = {
        'base_price': base_price,
        'logical_holding': logical_holding
    }

    try:
        with open(file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)
    except Exception as e:
        print(f"保存策略状态失败: {e}")
        
def get_grid_unit(stock, price, atr):
    if stock == "159985.SZ":
        return max(atr, price * 0.01)
    
    return atr
