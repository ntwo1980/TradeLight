#encoding:gbk
import datetime
import time
import pandas as pd
import numpy as np
import talib
import json
import os

"""
Strategy Description: 有色网格
"""

class a():
    pass

A = a()  # Create an empty class instance to store state

def init(C):
    A.stock = '159980.SZ'
    A.stock_name = '有色'
    A.strategy_name = 'grid_' + A.stock.replace(".", "") + '_a'

    A.acct = account
    A.acct_type = accountType
    A.unit_amount = 20000
    A.state_file =  A.strategy_name + "_" + A.stock_name +'.json'
    A.waiting_list = []  # Pending orders, to prevent duplicate submission
    A.prices = None
    A.prices_date = None
    A.base_price = None
    A.logical_holding = 0
    A.atr = 0
    A.rsi = 50
    A.grid_unit = 0
    A.max_price = 0
    A.yesterday_price = 0

    C.set_universe([A.stock])

    A.waiting_list = rebuild_waiting_list_from_open_orders()

    state = load_strategy_state(A.state_file, A.stock)
    if state and state['base_price'] is not None:
        A.base_price = state['base_price']
        A.logical_holding = state['logical_holding']
        print(f"Loaded state from file: base_price={A.base_price}, position={A.logical_holding}")
    else:
        print("No historical state found, will initialize base_price using first average")

    C.run_time("f","60nSecond","2019-10-14 09:30:00")
    C.run_time("g","1nDay","2019-10-14 14:59:30")

def f(C):
    now = datetime.datetime.now()
    now_time = now.strftime('%H%M%S')
    today = now.strftime('%Y%m%d')
    yesterday = (now - datetime.timedelta(days=1)).strftime('%Y%m%d')

    # Skip non-trading time
    if not ('093000' <= now_time <= '113000' or '130000' <= now_time <= '150000'):
        return

    account = get_trade_detail_data(A.acct, A.acct_type, 'account')
    if len(account) == 0:
        print(f'Account {A.acct} is not logged in, please check')
        return
    account = account[0]
    available_cash = int(account.m_dAvailable)

    if A.waiting_list:
        found_list = []
        orders = get_trade_detail_data(A.acct, A.acct_type, 'order')
        for order in orders:
            if order.m_strRemark in A.waiting_list:
                if order.m_nOrderStatus in {54, 56, 57}:  # 已撤, 已成, 废单
                    found_list.append(order.m_strRemark)
        A.waiting_list = [i for i in A.waiting_list if i not in found_list]
    if A.waiting_list:
        print(f"There are pending orders not confirmed: {A.waiting_list},暂停后续报单")
        return

    # Get position
    positions = get_trade_detail_data(A.acct, A.acct_type, 'position')
    holdings = {}
    for pos in positions:
        key = pos.m_strInstrumentID + '.' + pos.m_strExchangeID
        holdings[key] = pos.m_nCanUseVolume  # Available quantity for selling

    current_holding = holdings.get(A.stock, 0)

    # === Core logic ===
    executed = False

    # Get current market price
    stock = A.stock
    data = C.get_full_tick([stock])

    if A.stock not in data:
        print(f"Failed to get real-time price for {stock}")
        return

    current_price = data[stock]['lastPrice']

    if A.prices_date is None or A.prices_date != yesterday:
        prices = C.get_market_data_ex(['high','low','close'],[stock], period = "1d",count=30,end_time = yesterday)
        A.prices_date = yesterday
        A.prices = prices[stock]
        prices = A.prices
        A.yesterday_price = prices['close'][-1]

        avg_price = prices['close'][-10:].mean()
        A.max_price = prices['close'][-10:].max()

        high = prices['high']
        low = prices['low']
        close = prices['close']
        A.rsi = talib.RSI(close, timeperiod=6)[-1]

        A.atr = talib.ATR(high.values, low.values, close.values, timeperiod=4)[-1]
        A.grid_unit = get_grid_unit(stock, A.yesterday_price, A.atr)

    if A.grid_unit == 0 or A.max_price == 0:
        print("grid_unit or A.max_price is 0")
        return

    base_price = A.base_price  # copy a local base_price

    if base_price is None:
        base_price = A.max_price

    print({
        'stock': A.stock,
        'stock_name': A.stock_name,
        'yesterday': A.prices['close'].index[-1],
        'yesterday_price': A.yesterday_price,
        'current_price': current_price,
        'base_price': base_price,
        'atr': A.atr,
        'grid_unit': A.grid_unit})

    if current_price >= base_price + A.grid_unit:
        sell_amount = A.unit_amount  # Base selling amount
        if A.rsi > 80:
            pass
        else:
            sell_amount *= 0.9  # 90% of the amount

        # Calculate number of units to sell based on current price
        unit_to_sell = int(sell_amount / current_price)

        # Round down to nearest multiple of 100
        unit_to_sell = (unit_to_sell // 100) * 100

        # Ensure sell quantity does not exceed current holding
        unit_to_sell = min(unit_to_sell, current_holding)

        if unit_to_sell > 0:  # Ensure at least 100 shares
            timestamp = int(time.time())
            msg = f"{A.strategy_name}_sell_{unit_to_sell}_{timestamp}"
            passorder(24, 1101, A.acct, stock, 14, -1, unit_to_sell, A.strategy_name, 2, msg, C)
            A.waiting_list.append(msg)
            print("Sell %d shares, price: %.3f, total amount: %.2f" % (unit_to_sell, current_price, unit_to_sell * current_price))
            A.logical_holding -= unit_to_sell
            if A.logical_holding > 0:
                A.base_price = current_price
            else:
                A.base_price = None

            executed = True
            if A.base_price is not None:
                print("Updated base price to: %.3f" % A.base_price)
            else:
                print("Updated base price to: None")
    # Price drops below grid: buy one unit (based on amount)
    else:
        if current_price <= base_price - A.grid_unit:
            buy_amount = A.unit_amount  # Base buying amount
            if A.rsi < 20:
                buy_amount *= 1.1  # Increase by 10%

            # Calculate number of shares to buy
            unit_to_buy = int(buy_amount / current_price)

            # Round down to nearest multiple of 100
            unit_to_buy = (unit_to_buy // 100) * 100

            if available_cash >= current_price * unit_to_buy and unit_to_buy > 0:
                timestamp = int(time.time())
                msg = f"{A.strategy_name}_buy_{unit_to_buy}_{timestamp}"
                passorder(23, 1101, A.acct, stock, 14, -1, unit_to_buy, A.strategy_name, 2, msg, C)
                A.waiting_list.append(msg)
                print("Buy %d shares, price: %.3f, total amount: %.2f" % (unit_to_buy, current_price, unit_to_buy * current_price))
                # Update base price to current price
                A.base_price = current_price
                A.logical_holding += unit_to_buy
                executed = True
                print("Updated base price to: %.3f" % A.base_price)
            else:
                print("Insufficient cash or calculated shares is zero, cannot buy")

    if executed:
        save_strategy_state(A.state_file, stock, A.base_price, A.logical_holding)
        if A.base_price is not None:
            print(f"State saved: base_price={A.base_price:.3f}, position={A.logical_holding}")
        else:
            print(f"State saved: base_price=None, position={A.logical_holding}")

def g(C):
    state = load_strategy_state(A.state_file, A.stock)
    if state and state['base_price'] is not None:
        A.base_price = state['base_price']
        A.logical_holding = state['logical_holding']

        data = C.get_full_tick([A.stock])

        if A.stock not in data:
            print(f"Failed to get real-time price for {A.stock}")
            return

        current_price = data[A.stock]['lastPrice']

        if A.logical_holding > 0 and A.base_price is not None and abs(A.base_price / current_price - 1) > 0.05:
            original_base_price = A.base_price
            beta = 0.1  # Tracking speed: 0.1~0.3 (larger = faster)
            A.base_price = A.base_price + beta * (current_price - A.base_price)

            save_strategy_state(A.state_file, A.stock, A.base_price, A.logical_holding)
            print(f"Dynamic adjustment of base_price: original={original_base_price:.3f}, new={A.base_price:.3f}, current price={current_price:.3f}")

def rebuild_waiting_list_from_open_orders():
    orders = get_trade_detail_data(A.acct, A.acct_type, 'order')
    open_orders = []
    for order in orders:
        if order.m_nOrderStatus in [49, 50, 51, 52, 55] and A.strategy_name in order.m_strRemark:  # 待报, 已报, 已报待撤, 部成待撤, 部成
            open_orders.append(order.m_strRemark)

    return open_orders

def load_strategy_state(file, stock):
    """Load strategy state from file"""
    if not os.path.exists(file):
        return None
    try:
        with open(file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            # Check if state for current stock exists
            if stock in data:
                state = data[stock]
                return {
                    'base_price': state.get('base_price'),
                    'logical_holding': state.get('logical_holding', 0)
                }
    except Exception as e:
        print(f"Failed to load strategy state: {e}")
    return None

def save_strategy_state(file, stock, base_price, logical_holding):
    """Save strategy state to file"""
    data = {}
    if os.path.exists(file):
        try:
            with open(file, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            print(f"Error reading state file, will create new: {e}")

    # Update state for current stock
    data[stock] = {
        'base_price': base_price,
        'logical_holding': logical_holding
    }

    try:
        with open(file, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)
    except Exception as e:
        print(f"Failed to save strategy state: {e}")

def get_grid_unit(stock, price, atr):
    if stock == "159985.SZ":
        return max(atr, price * 0.01)

    return atr
