#encoding:gbk
import datetime
import time
import pandas as pd
import numpy as np
import talib
import json
import os

"""
Strategy Description: 豆粕网格
"""

  
namespace = {}
with open('Strategy.py', "r", encoding="utf-8") as f:
    exec(f.read(), globals())  # 注入全局
    
a = SimpleGridStrategy(
    stocks=["159985.SZ"], 
    stockNames=['豆粕'],
    get_trade_detail_data_func = get_trade_detail_data)

def init(C): 
    a.init(C)
    if not a.IsBacktest:
        C.run_time("f","60nSecond","2019-10-14 09:30:00")
        C.run_time("g","1nDay","2019-10-14 14:59:30")

def handlebar(C):
    if a.IsBacktest:
        f(C)

def f(C):
    if a.IsBacktest:
        yesterday = timetag_to_datetime(C.get_bar_timetag(C.barpos - 1), '%Y%m%d%H%M%S')
    else:
        now = datetime.datetime.now()
        now_time = now.strftime('%H%M%S')
        
        if not ('093000' <= now_time <= '113000' or '130000' <= now_time <= '150000'):
            return
        
        today = now.strftime('%Y%m%d')
        yesterday = (now - datetime.timedelta(days=1)).strftime('%Y%m%d')

    available_cash = a.GetAvailableCash()
    
    if not a.IsBacktest:
        a.RefreshWaitingList()
        if a.WaitingList:
            print(f"There are pending orders not confirmed: {a.WaitingList},暂停后续报单")
            return
            
    # Get position
    holdings = a.GetPositions()
 
    current_holding = holdings.get(a.Stocks[0], 0)

    # === Core logic ===
    executed = False

    # Get current market price

    if a.prices_date is None or a.prices_date != yesterday:
        stock = a.Stocks[0]
        prices = C.get_market_data_ex(['high','low','close'],[stock], period = "1d",count=30,end_time = yesterday)
        a.prices_date = yesterday
        a.prices = prices[stock]
        prices = a.prices
        a.yesterday_price = prices['close'][-1]

        avg_price = prices['close'][-10:].mean()
        a.max_price = prices['close'][-10:].max()

        current_price = prices['close'][-1]
        high = prices['high']
        low = prices['low']
        close = prices['close']
        a.rsi = talib.RSI(close, timeperiod=6)[-1]

        a.atr = talib.ATR(high.values, low.values, close.values, timeperiod=4)[-1]
        a.grid_unit = get_grid_unit(stock, a.yesterday_price, a.atr)

    if a.grid_unit == 0 or a.max_price == 0:
        print("grid_unit or a.max_price is 0")
        return
        
    if not a.IsBacktest:
        current_prices = a.GetTicketPrices(a.Stocks, C)
        current_price = current_prices[a.Stocks[0]]['lastPrice']
    
    a.current_price = current_price

    base_price = a.base_price  # copy a local base_price

    if base_price is None:
        base_price = a.max_price
            
    print({
        'stock': a.Stocks[0],
        'stock_name': a.StockNames[0],
        'yesterday': a.prices['close'].index[-1],
        'yesterday_price': a.yesterday_price,
        'current_price': current_price,
        'base_price': base_price,
        'atr': a.atr,
        'grid_unit': a.grid_unit})
    

    if current_price >= base_price + a.grid_unit:
        sell_amount = a.TradingAmount  # Base selling amount
        if a.rsi > 80:
            pass
        else:
            sell_amount *= 0.9  # 90% of the amount

        # Calculate number of units to sell based on current price
        unit_to_sell = int(sell_amount / current_price)

        # Round down to nearest multiple of 100
        unit_to_sell = (unit_to_sell // 100) * 100

        # Ensure sell quantity does not exceed current holding
        unit_to_sell = min(unit_to_sell, current_holding)
        
        if unit_to_sell > 0:  # Ensure at least 100 shares
            timestamp = int(time.time())
            strategyName = a.GetUniqueStrategyName(a.Stocks[0])
            msg = f"{strategyName}_sell_{unit_to_sell}_{timestamp}"
            passorder(24, 1101, a.Account, a.Stocks[0], 14, -1, unit_to_sell, strategyName, 2, msg, C)
            a.WaitingList.append(msg)
            print("Sell %d shares, price: %.3f, total amount: %.2f" % (unit_to_sell, current_price, unit_to_sell * current_price))
            a.logical_holding -= unit_to_sell
            if a.logical_holding > 0:
                a.base_price = current_price
            else:
                a.base_price = None

            executed = True
            if a.base_price is not None:
                print("Updated base price to: %.3f" % a.base_price)
            else:
                print("Updated base price to: None")
    # Price drops below grid: buy one unit (based on amount)
    else:
        if current_price <= base_price - a.grid_unit:
            buy_amount = a.TradingAmount  # Base buying amount
            if a.rsi < 20:
                buy_amount *= 1.1  # Increase by 10%

            # Calculate number of shares to buy
            unit_to_buy = int(buy_amount / current_price)

            # Round down to nearest multiple of 100
            unit_to_buy = (unit_to_buy // 100) * 100

            if available_cash >= current_price * unit_to_buy and unit_to_buy > 0:
                timestamp = int(time.time())
                strategyName = a.GetUniqueStrategyName(a.Stocks[0])
                msg = f"{strategyName}_buy_{unit_to_buy}_{timestamp}"
                passorder(23, 1101, a.Account, a.Stocks[0], 14, -1, unit_to_buy, strategyName, 2, msg, C)
                a.WaitingList.append(msg)
                print("Buy %d shares, price: %.3f, total amount: %.2f" % (unit_to_buy, current_price, unit_to_buy * current_price))
                # Update base price to current price
                a.base_price = current_price
                a.logical_holding += unit_to_buy
                executed = True
                print("Updated base price to: %.3f" % a.base_price)
            else:
                print("Insufficient cash or calculated shares is zero, cannot buy")

    if executed:
        a.SaveStrategyState(a.Stocks, a.StockNames, a.base_price, a.logical_holding)

        if a.base_price is not None:
            print(f"State saved: base_price={a.base_price:.3f}, position={a.logical_holding}")
        else:
            print(f"State saved: base_price=None, position={a.logical_holding}")
    elif a.IsBacktest:
        g(C)

def g(C):
    a.LoadStrategyState(a.Stocks, a.StockNames)
    state = a.State
    
    if not a.IsBacktest and state and state['base_price'] is not None:
        a.base_price = state['base_price']
        a.logical_holding = state['logical_holding']
        
    stock = a.Stocks[0]

    if a.logical_holding > 0 and a.base_price is not None and abs(a.base_price / a.current_price - 1) > 0.04:
        original_base_price = a.base_price
        beta = 0.1  # Tracking speed: 0.1~0.3 (larger = faster)
        a.base_price = a.base_price + beta * (a.current_price - a.base_price)

        a.SaveStrategyState(a.Stocks, a.StockNames, a.base_price, a.logical_holding)
        print(f"Dynamic adjustment of base_price: original={original_base_price:.3f}, new={a.base_price:.3f}, current price={a.current_price:.3f}")
        

def get_grid_unit(stock, price, atr):
    if stock == "159985.SZ":
        return max(atr, price * 0.01)

    return atr
